Reference:
https://github.com/manili/VSDBabySoC
https://github.com/hemanthkumardm/SFAL-VSD-SoC-Journey/tree/main/12.%20VSDBabySoC%20Project
https://github.com/Dhinu29/P_DINESH_WEEK_2_RISC_V_SoC_Tapeout_Program_VSD/tree/main
---

WEEK_2_RISC_V_SOC_TAPEOUT_PROGRAM_VSD  

---
Week 2 Task â€“ BabySoC Fundamentals & Functional Modelling
Objective:
To build a solid understanding of SoC fundamentals and practice functional modelling of
the BabySoC using simulation tools (Icarus Verilog & GTKWave).
---
Focus on: 
o What is a System-on-Chip (SoC)? 
o Components of a typical SoC (CPU, memory, peripherals, interconnect). 
o Why BabySoC is a simplified model for learning SoC concepts. 
o The role of functional modelling before RTL and physical design stages. 
----
## System-on-Chip (SoC): A Concise Overview

A **System-on-Chip (SoC)** is a complete electronic system built onto a single integrated circuit (chip). It integrates all necessary componentsâ€”the processor, memory, and communication toolsâ€”into one compact package. This integration makes devices **smaller, faster, and more power-efficient**.

***

### 1. What is a System-on-Chip (SoC)? 

An SoC is a "mini-computer" on a single die. Its main purpose is to serve as the core processor for modern electronic devices where **Space, Power, and Efficiency** are critical (e.g., smartphones, smartwatches, IoT gadgets).

* **Integration:** Consolidates multiple functional blocks (like CPU, GPU, Memory, I/O) onto one silicon chip.
* **Key Benefits:** Drastically reduces the physical size, lowers power consumption (crucial for battery life), and improves overall processing speed due to shorter data travel paths.

***

### 2. Components of a Typical SoC 

A typical SoC combines various functional blocks that work together to create a complete, functioning system, encompassing both general processing and specialized tasks:

| Component | Simple Description | Function in the SoC |
| :--- | :--- | :--- |
| **CPU (Central Processing Unit)** | The **Brain** of the system. | Executes all general-purpose instructions, runs the operating system, and manages applications. Modern SoCs often feature multi-core designs (e.g., RISC-V cores). |
| **Memory** | **Storage** for data and instructions. | Includes high-speed **SRAM** (for cache/registers) and **DRAM** or **Flash** (for main, volatile, or non-volatile storage). |
| **Interconnect (Bus/NoC)** | The **Internal Road System** (like an AXI Bus or Network-on-Chip). | Enables high-speed, reliable communication and data exchange between all the individual components on the chip. |
| **Peripherals & I/O** | **Interfaces and Specialized Handlers** that connect the SoC to the external world. | Includes specialized processing units like the **GPU** (for graphics) and **DSP** (for audio/video), as well as standard communication interfaces (USB, HDMI, UART, SPI, etc.). |
| **Power Management Unit (PMU)** | Regulates and distributes power across the chip, ensuring components operate efficiently and extending battery life. |
| **Special Features / IP Blocks** | **Additional, dedicated modules** that vary by product purpose. | Includes modules like **Wi-Fi, Bluetooth, security cores, cryptography engines,** and **AI accelerators** (or dedicated hardware for machine learning). |
| **Clock & Timing Units** | **System timing control.** | Manages system timing, often using integrated **PLL (Phase-Locked Loops),** ensuring synchronous and accurate operation of the CPU, memory, and peripherals. |
| **Analog Components / DACs** | **Digital-to-Analog Converters.** | Converts digital signals into analog output for audio, video, or interfacing with external analog sensors and devices. |

***

### 3. Types of System-on-Chip (SoC) Architectures 

SoCs are often categorized based on the complexity of their core processor and their intended application:

| SoC Type | Core Component | Primary Application & Characteristics |
| :--- | :--- | :--- |
| **Microcontroller-based** | **Microcontroller (MCU)** | Designed for **simple control tasks, low power, and high efficiency.** Ideal for systems with minimal processing needs. **Examples:** IoT sensors, basic smart appliances. |
| **Microprocessor-based** | **Microprocessor ($\mu$P)** | Built to handle **demanding tasks and run complex Operating Systems (OS).** Provides higher general performance and multi-tasking capabilities. **Examples:** Smartphones, tablets, advanced computing devices. |
| **Application-Specific** | **Highly Optimized Core(s)** | **Custom-designed for a single, high-performance task.** Optimized for maximum speed and efficiency in a specific domain. **Examples:** Dedicated Graphics Cards (GPUs), AI/Machine Learning accelerators. |

***
Soc DEsign flow image

---
## VSDBabySoC (BabySoC) Overview

The **VSDBabySoC (BabySoC)** is a small, highly efficient **System-on-Chip (SoC)** primarily designed as an **educational platform** for embedded systems and mixed-signal (digital-analog) interfacing. Built using Sky130 technology, its key objective is to facilitate simultaneous testing of open-source IP cores and analog component calibration.

***

### 1. Key Components of BabySoC ðŸ—ï¸

The BabySoC is a mixed-signal system, integrating essential digital and analog blocks:

| Component | Type | Function |
| :--- | :--- | :--- |
| **RVMYTH Microprocessor** | Digital (RISC-V CPU) | The central **processing unit and brain**. Handles all computational tasks, executes instructions, and, critically, **prepares and cycles data** for the DAC (specifically using the `r17` register). |
| **8x Phase-Locked Loop (PLL)** | Analog/Mixed-Signal | Generates a **stable and synchronized clock signal**. This is vital for coordinating the operation of the RVMYTH CPU and the DAC, ensuring all components operate in harmony and maintain data integrity. |
| **10-bit Digital-to-Analog Converter (DAC)** | Analog | Receives digital data from the RVMYTH processor and converts it into a continuous **analog output signal**. This block facilitates the system's external interfacing capabilities. |

***

### 2. BabySoC Functionality and Role ðŸ’¡

The BabySoC's function centers on digital data processing for analog signal generation:

* **Initialization & Clock Synchronization:** The SoC begins by activating the **PLL** upon receiving an initial input. The PLL's synchronized clock ensures precise, simultaneous operation between the RVMYTH core and the DAC.
* **Data Processing (RVMYTH):** The RVMYTH core continuously processes and updates values stored in its **r17 register**. This process creates a continuous digital data stream for analog conversion.
* **Analog Output Generation (DAC):** The DAC takes the data from `r17` and converts it into an analog signal. This output is stored in a file (named **OUT** in the example) and can drive **multimedia outputs** (audio or video) when connected to external consumer electronics like TVs or mobile phones.
* **Educational Focus:** The platform's highly documented nature makes it an ideal environment for students and engineers to learn about modern embedded system design, RISC-V architecture, and fundamental digital-analog interfacing.

***
---
## Why BabySoC is a Simplified Model for Learning SoC Concepts ðŸ‘¶

The **VSDBabySoC (BabySoC)** is an ideal, simplified platform for learning complex System-on-Chip (SoC) concepts because it focuses on a **minimal but complete** set of functionality, effectively demonstrating core principles without the overwhelming complexity of a commercial chip.

1.  **Minimal Component Set:** Commercial SoCs have dozens of complex IP blocks (multi-core CPUs, multiple GPUs, large memory controllers, etc.). BabySoC features only **three core components** ($\text{RVMYTH CPU} + \text{PLL} + \text{DAC}$), allowing learners to focus on how a small number of essential digital and analog blocks integrate and communicate.
2.  **Clear Interfacing:** It provides a direct, easy-to-trace example of **digital-to-analog interfacing**. The flow of data from the digital CPU register (`r17`) to the analog output is simple, concrete, and measurable, making the concept of mixed-signal integration highly accessible.
3.  **Educational Objective:** Unlike commercial chips designed for mass market performance, BabySoC was explicitly designed as an **educational platform** built on open-source technology ($\text{Sky130}$), meaning its documentation, verification environment, and internal workings are transparent and easy to analyze.

***

## The Role of Functional Modeling in SoC Design ðŸ› ï¸

**Functional modeling** (or system-level modeling) is the crucial first step in the SoC design flow, performed **before** the Register-Transfer Level ($\text{RTL}$) and physical design stages.

Functional modeling defines *what* the chip must do, while RTL and physical design determine *how* it will do it in hardware.

| Stage | Purpose | Description |
| :--- | :--- | :--- |
| **Functional Modeling (Initial Stage)** | **High-Level Verification of System Behavior** | This stage uses high-level programming languages ($\text{C} / \text{C}++$, Python, or specialized system languages) to quickly model the **expected behavior** and **algorithms** of the entire SoC. It verifies that the architecture, communication protocols, and overall data flow *conceptually* work before investing time in detailed hardware description. |
| **RTL Design (Intermediate Stage)** | **Hardware Implementation** | Translates the verified functional model into hardware description languages ($\text{Verilog}$ or $\text{VHDL}$), defining the actual structure and timing of digital circuits (e.g., flip-flops, registers, logic gates). |
| **Physical Design (Final Stage)** | **Silicon Layout** | Transforms the RTL code into the physical layout (GDSII file) for manufacturing, including placement, routing, and timing closure. |

### Importance Before RTL and Physical Design:

1.  **Early Bug Detection:** It is significantly **faster and cheaper** to find and fix architectural or algorithmic errors in a software model than to fix them in $\text{RTL}$ code or, worse, after the chip has been manufactured ($\text{Tapeout}$).
2.  **Architectural Exploration:** It allows designers to rapidly evaluate different system architectures (e.g., how many processors to use, which bus to select) and performance trade-offs without writing extensive hardware code.
3.  **Specification Validation:** Ensures the system specification (the requirements document) is correctly interpreted and implemented before moving to the detailed, time-consuming hardware design phases.  

----
## VSDBabySoC Modeling and Simulation Plan

The primary goal of this stage is to functionally model and simulate the **VSDBabySoC** using industry-standard open-source tools ($\text{Iverilog}$ and $\text{GTKWave}$). This process verifies the integration and synchronous operation of the core IP blocks before proceeding to the physical design flow.

### Simulation Flow Overview 

The simulation setup involves four main elements: three $\text{IP}$ cores and a wrapper, all driven by a $\text{Testbench}$ module.

1.  **Initial Signal Input:** The $\text{Testbench}$ feeds initial input signals to the `vsdbabysoc` wrapper.
2.  **Clock Generation:** The **PLL** is activated and begins generating a stable, synchronized $\text{CLK}$ signal.
3.  **Instruction Execution:** The $\text{CLK}$ signal drives the **RVMYTH** core, which executes instructions stored in its $\text{IMEM}$.
4.  **Data Cycling:** RVMYTH sequentially fills its **$\text{r17}$ register** with digital values.
5.  **Analog Conversion:** The **DAC** receives the digital values from $\text{r17}$ and converts them into the final **analog output signal, $\text{OUT}$**.

The entire system is captured and visualized using $\text{Iverilog}$ (for simulation) and $\text{GTKWave}$ (for waveform viewing).

***

### Modeling the IP Cores 

The $\text{SoC}$ integrates a mix of digital and analog/mixed-signal $\text{IP}$ cores, modeled as follows:

| IP Core | Description | Modeling Language / Tool | Reference Repository |
| :--- | :--- | :--- | :--- |
| **RVMYTH Microprocessor** | Digital (RISC-V $\text{CPU}$) | Originally designed in **TL-Verilog** and converted to standard $\text{Verilog}$ using the **Sandpiper-SaaS** tool. | [shivanishah269/risc-v-core](https://github.com/shivanishah269/risc-v-core) |
| **10-bit DAC** | Analog | Modeled in $\text{Verilog}$ using the **`real` datatype** to simulate analog behavior, allowing functional verification. | [vsdip/rvmyth\_avsddac\_interface](https://github.com/vsdip/rvmyth_avsddac_interface) |
| **PLL (AVSDPLL)** | Analog/Mixed-Signal | Modeled in $\text{Verilog}$ using the **`real` datatype**. *Note: The initial model was updated to $\text{AVSDPLL}$ to ensure sufficiency for the physical design flow.* | Initial: [vsdip/rvmyth\_avsdpll\_interface](https://github.com/vsdip/rvmyth_avsdpll_interface) $\implies$ Final: [lakshmi-sathi/avsdpll\_1v8](https://github.com/lakshmi-sathi/avsdpll_1v8) |

**Digital-Analog Modeling Note:** Since standard $\text{Verilog}$ synthesis tools cannot process analog circuits, the $\text{PLL}$ and $\text{DAC}$ are functionally modeled using the $\text{Verilog}$ **`real` datatype** to simulate their behavior during the digital simulation phase.

***
---
Project Structure
src/include/ - Contains header files (*.vh) with necessary macros or parameter definitions.
src/module/ - Contains Verilog files for each module in the SoC design.
output/ - Directory where compiled outputs and simulation files will be generated.  
Pre-requirements
   -Icarus Verilog for compilation
   -Gtkwave for viewing waveform 
    -Linux environment  
Step-by-Step Guide:
1.Setup and Prepare Project Directory
 clone the directory from 
"https://github.com/manili/VSDBabySoC.git" in my vlsi folder structure as follows:
"VSDBabySoC/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ include/
â”‚   â”‚   â”œâ”€â”€ sandpiper.vh
â”‚   â”‚   â””â”€â”€ other header files...
â”‚   â”œâ”€â”€ module/
â”‚   â”‚   â”œâ”€â”€ vsdbabysoc.v      # Top-level module integrating all components
â”‚   â”‚   â”œâ”€â”€ rvmyth.v          # RISC-V core module
â”‚   â”‚   â”œâ”€â”€ avsdpll.v         # PLL module
â”‚   â”‚   â”œâ”€â”€ avsddac.v         # DAC module
â”‚   â”‚   â””â”€â”€ testbench.v       # Testbench for simulation
â””â”€â”€ output/
â””â”€â”€ compiled_tlv/         # Holds compiled intermediate files if needed
"  
Module Descriptions
 vsdbabysoc.v (Top-Level SoC Module)
This is the top-level module that integrates the rvmyth, pll, and dac modules.
[VSDBabySoC](https://github.com/manili/VSDBabySoC.git)
"
  - Inputs:
     - reset: Resets the core processor.
     - VCO_IN, ENb_CP, ENb_VCO, REF: PLL control signals.
     - VREFH: DAC reference voltage.
  - Outputs:
     - OUT: Analog output from DAC.
     - Connections:
     - RV_TO_DAC - A 10-bit bus that connects the RISC-V core output to the DAC input.
     - CLK - The clock signal generated by the PLL.
"
 rvmyth.v (RISC-V Core)
The rvmyth module is a simple RISC-V based processor. It outputs a 10-bit digital signal (OUT) to be converted by the DAC.
[rvmyth](https://github.com/kunalg123/rvmyth/)

"  Inputs:
     - CLK: Clock signal generated by the PLL.
     - reset: Initializes or resets the processor.
  Outputs:
     - OUT: A 10-bit digital signal representing processed data to be sent to the DAC.
"
 avsdpll.v (PLL Module)
The pll module is a phase-locked loop that generates a stable clock (CLK) for the RISC-V core.
[Introduction](https://github.com/ireneann713/PLL.git) [avsdpll](https://github.com/lakshmi-sathi/avsdpll_1v8.git)

 " Inputs:
     - VCO_IN, ENb_CP, ENb_VCO, REF: Control and reference signals for PLL operation.
  Output:
     - CLK: A stable clock signal for synchronizing the core and other modules.
"

avsddac.v (DAC Module)
The dac module converts the 10-bit digital signal from the rvmyth core to an analog output.
[avsddac](https://github.com/vsdip/rvmyth_avsddac_interface.git)

 " Inputs:
     - D: A 10-bit digital input from the processor.
     - VREFH: Reference voltage for the DAC.
  Output:
     - OUT: Analog output signal.
"


### A. Environment Setup & $\text{RTL}$ Generation

First, set up the Python virtual environment and use $\text{Sandpiper-SaaS}$ to translate the $\text{TL-Verilog}$ code ($\text{rvmyth.tlv}$) into standard $\text{Verilog}$ ($\text{rvmyth.v}$).

| Command | Purpose |
| :--- | :--- |
| **Project Navigation** | |
| `git clone https://github.com/manili/VSDBabySoC.git` | Clones the repository to your local machine. |
| `cd VSDBabySoC` | Enters the project root directory. |
| `ls` | Confirms the directory contents (optional). |
| `cd src/module` | Navigates to the directory containing the source files. |
| `ls` | Confirms the Verilog and $\text{TL-Verilog}$ files are present. |
| **Sandpiper Setup** | |
| `sudo apt update` | Updates the package list (optional, but good practice). |
| `sudo apt install python3-venv python3-pip` | Installs necessary Python tools. |
| `python3 -m venv sp_env` | Creates a new isolated Python virtual environment. |
| `source sp_env/bin/activate` | **Activates** the virtual environment. |
| `pip install pyyaml click sandpiper-saas` | Installs the $\text{Sandpiper-SaaS}$ tool and its dependencies. |
| **Compile TL-Verilog to RTL** | |
| `sandpiper-saas -i ./src/module/*.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/` | Compiles the $\text{TL-Verilog}$ file (`rvmyth.tlv`) into standard $\text{Verilog}$ ($\text{rvmyth.v}$) in the `src/module` directory. |

---

### B. Compile, Run Simulation, and View Waveforms

Now that the $\text{RVMYTH}$ core is available as $\text{Verilog}$ $\text{RTL}$, the entire $\text{BabySoC}$ can be compiled and simulated using $\text{Icarus Verilog}$.

| Command | Purpose |
| :--- | :--- |
| **Prepare Output & Compile** | |
| `mkdir -p output/pre_synth_sim` | Creates the directory for simulation output files. |
| `iverilog -o output/pre_synth_sim/pre_synth_sim.out -DPRE_SYNTH_SIM -I src/include -I src/module src/module/testbench.v` | **Compiles the $\text{SoC}$:** Creates an executable (`pre_synth_sim.out`) by linking the `testbench.v` with all necessary modules and header files. |
| **Execute Simulation** | |
| `cd output/pre_synth_sim` | Navigates to the output directory. |
| `ls` | Confirms the executable (`pre_synth_sim.out`) is present. |
| `./pre_synth_sim.out` | **Runs the simulation.** The testbench executes and generates the waveform data file (`pre_synth_sim.vcd`). |
| **View Waveform** | |
| `gtkwave pre_synth_sim.vcd` | **Opens the waveform file** in $\text{GTKWave}$ to visually verify the functionality of $\text{RVMYTH}$, $\text{PLL}$, and $\text{DAC}$. |   

screenshots 

## Key Signals for Functional Simulation Analysis

| Signal Name | Source Module / Register | Type / Role | Description for Analysis |
| :--- | :--- | :--- | :--- |
| **CLK** | **PLL** ($\text{Phase-Locked Loop}$) | **Input to $\text{RVMYTH}$** | The primary clock signal for the $\text{RVMYTH}$ core. Its stability and synchronization with the system must be verified. |
| **reset** | **External Source** | **Input to $\text{RVMYTH}$** | The system reset signal. Must be monitored to ensure the $\text{RVMYTH}$ core starts execution from a known state (usually after being de-asserted). |
| **RV\_TO\_DAC[9:0]** | **RVMYTH** (Register \#17) | **10-bit Digital Output** | The digital data stream generated by the $\text{RVMYTH}$ $\text{CPU}$ that is fed directly into the $\text{DAC}$. Monitoring this shows the $\text{CPU}$'s processing activity. |
| **OUT (DAC Output)** | **DAC** (Digital-to-Analog Converter) | **`real` Datatype Wire** | Represents the analog voltage output of the $\text{DAC}$. You must analyze this signal to see if it correctly converts and reflects the sequence of digital values from **RV\_TO\_DAC**. |
| **OUT (SoC Top-Level)** | **VSDBabySoC** (Top-level) | **Output Port** | The final output port of the entire $\text{VSDBabySoC}$ module. (In this $\text{Verilog}$ functional simulation, this signal still uses digital representation, which is an inherent limitation when simulating analog functions in a purely digital flow). |

---  
RTL Synthesis using Yosys 
"
yosys
yosys> read_verilog  -sv -I src/include/ -I src/module/ src/module/vsdbabysoc.v src/module/clk_gate.v src/module/rvmyth.v

yosys> read_liberty -lib /home/DINESH/Desktop/Open_Source_EDA_Tool/yosys/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_liberty -lib src/lib/avsddac.lib
 
read_liberty -lib src/lib/avsdpll.lib

read_liberty -lib src/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

synth -top vsdbabysoc

write_verilog vsdbabysoc.synth.v

abc -liberty src/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show vsdbabysoc
"
Post-Synthesis Simulation:
"iverilog -o output/post_synth_sim/post_synth_sim.out -DPOST_SYNTH_SIM  -I src/include/ -I src/module/ src/module/testbench.v
 cd output/post_synth_sim
 vvp post_synth_sim.out
gtkwave post_synth_sim.vcd
"
