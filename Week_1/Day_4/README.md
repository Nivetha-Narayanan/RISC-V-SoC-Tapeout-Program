This is an excellent summary of your Day 4 tasks on **GLS, Blocking/Non-blocking, and Synthesis-Simulation Mismatch**. You've highlighted the crucial points where RTL code (what you write) can behave differently from the synthesized netlist (what the hardware tool creates).

I have corrected spelling mistakes, clarified concepts, and formatted the document using Markdown, including the necessary placeholders for your screenshots and code blocks.

-----

# üóìÔ∏è Day 4: GLS, Blocking and Non-blocking, and Synthesis-Simulation Mismatch

This day focuses on validating the synthesized hardware (netlist) and understanding common coding pitfalls that cause the RTL simulation to differ from the Gate-Level Simulation.

-----

## 1\. Gate-Level Simulation (GLS)

**What is GLS?**
GLS is the process of simulating the design using the **netlist** (the structural gate-level representation) instead of the **RTL** (Register Transfer Level) code.

  * **Design Under Test (DUT):** The netlist, which is generated by the synthesis tool and contains only standard cells (AND, OR, DFF, etc.) and their connections.
  * **Logical Equivalence:** The netlist must be logically identical to the original RTL code. The **same testbench** used for RTL simulation must be used for GLS.

### Why GLS is Necessary

1.  **Verify Logical Correctness after Synthesis:** Ensures that the synthesis tool correctly mapped the abstract RTL logic to the physical standard cells without introducing errors.
2.  **Verify Timing:** GLS is often run with **delay annotation** (SDF‚ÄîStandard Delay Format) to check if the circuit meets all timing requirements (setup and hold times) *after* physical cell placement and routing are considered. (This is known as **Static Timing Analysis** or timing simulation).

### GLS Setup with Icarus Verilog (Iverilog)

The GLS requires you to compile not just the netlist, but also the **Verilog models** for every standard cell used in that netlist.

| Step | Command | Description |
| :--- | :--- | :--- |
| **RTL Simulation** | `iverilog ternary_operator_mux.v tb_ternary_operator_mux.v` | Compiles the abstract RTL code. |
| **GLS** | `iverilog primitives.v sky130_fd_sc_hd.v ternary_operator_mux_net.v tb_ternary_operator_mux.v` | Compiles the **gate models** (`primitives.v`, `sky130_fd_sc_hd.v`) along with the netlist (`*_net.v`). |

**Design Example:** For $Y = (A \cdot B) + C$, the netlist will contain two instantiated cells: `and g1(...)` and `or g2(...)`. The gate-level models provide the functional (and sometimes timing) behavior for these cells.

*(Screenshot of the terminal commands and output for GLS)*

-----

## 2\. Synthesis-Simulation Mismatch

A mismatch occurs when the behavior observed in your RTL simulation does **not** match the behavior in the GLS (which represents the physical chip). This is typically caused by ambiguous or non-standard Verilog coding styles.

The three primary causes are:

1.  Missing Sensitivity List
2.  Blocking vs. Non-Blocking Assignments
3.  Non-standard Verilog Coding

### A. Missing Sensitivity List (Combinational Logic)

In combinational logic (`always @(...)` blocks), the sensitivity list must include **all inputs** to the block.

| Problematic RTL (Missing Inputs) | Correct RTL (Standard for all inputs) |
| :--- | :--- |
| ` verilog always @(sel) // Only sensitive to 'sel' begin  if(sel) y=i0; else y=i1; end  ` | \`\`\`verilog
always @(i0 or i1 or sel) // Standard Verilog
begin
if(sel) y=i0;
else y=i1;
end
// OR, preferably:
always @(\*) // SystemVerilog/Yosys Standard

````|
| **Simulation Mismatch:** If `i0` or `i1` change, the output `y` **does not update** until `sel` changes. The synthesized hardware (a physical MUX) updates immediately, causing a mismatch. | **Correct Behavior:** Any change in `i0`, `i1`, or `sel` immediately reflects in `y`, matching the hardware. |

### B. Blocking (`=`) vs. Non-Blocking (`<=`) Assignments

This is the most common cause of mismatch in **sequential logic** (Flip-Flops), but it can also cause issues in combinational logic when statements have data dependencies.

| Assignment Type | Symbol | Execution Flow | Recommended Use |
| :--- | :--- | :--- | :--- |
| **Blocking** | `=` | Executes statements **sequentially**, blocking the execution of the next statement until the current one is complete. | **Combinational Logic** (`always @(*)`) |
| **Non-Blocking** | `_<=` | All Right-Hand Sides (RHS) are evaluated in **parallel** at the start of the block, and the assignments to Left-Hand Sides (LHS) occur simultaneously at the end of the block. | **Sequential Logic** (`always @(posedge clk)`) |

#### The Blocking Caveat Lab

This example illustrates a **combinational logic error** caused by using the **blocking assignment** in a way that doesn't map correctly to physical logic.

```verilog
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
begin
    d = x & c;  // Statement 1
    x = a | b;  // Statement 2
end
endmodule
````

1.  **RTL Simulation (Blocking):**
      * Statement 1 is executed **first**. It reads the **old value** of `x` (from before the block ran) to calculate `d`.
      * Statement 2 executes **second**. It calculates the **new value** of `x` based on `a` and `b`.
      * The output `d` has a **one-delta-cycle delay** from the inputs.
2.  **Synthesis (Hardware):**
      * Synthesis maps this to pure parallel combinational logic. The gates for `d = x & c` and `x = a | b` all exist in parallel.
      * The hardware cannot execute in a blocked order; `d` will be calculated directly based on the *current* state of `a`, `b`, and `c`, eliminating the delay seen in the RTL.

**Conclusion:** The RTL code will show a delayed output for `d`, while the GLS (hardware) will show an immediate output, causing a mismatch.

**RTL Simulation Waveform:**
*(GTKWave screenshot showing delayed output 'd')*

**GLS/Netlist Waveform:**
*(GTKWave screenshot showing immediate output 'd')*

*(The screenshots for the `mux` and `bad_mux` lab were likely omitted here as your version of Yosys correctly optimized them, demonstrating that tools are getting smarter at fixing simple mismatches).*

-----

I acknowledge the custom instructions you have provided.
