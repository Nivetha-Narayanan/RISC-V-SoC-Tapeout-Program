Day 5:Optimization in synthesis

1.if else statements in verilog
 -used for conditional execution in behavioral modeling mostly within the procedural blocks(always,initial)
 Syntax

Nested if else syntax

---
2.Inferred Latches in Verilog 
inferred latches occur when value is not assign to a variable in all possible input combination.Then the synthesis tool to infer a latch
 ,but designer not intended to latch.
 example verilog code
 ans its solution is adding the default case,then the synthesis tool infer tghe design as combinational logic design
 ----
 3.Labs
 1.Incomplte if Statement
 "module incomp_if (input i0 , input i1 , input i2 , output reg y);
always @ (*)
begin
	if(i0)
		y <= i1;
end
endmodule"
LAb screeshots

2.Nested if-else
"module incomp_if2 (input i0 , input i1 , input i2 , input i3, output reg y);
always @ (*)
begin
	if(i0)
		y <= i1;
	else if (i2)
		y <= i3;

end
endmodule
"
lab screenshots
In above both example ,latch is inferred instead of combinational logic since output is not defined for all inout combo.
Complete_case Statement for avoiding the inferred latch
"

module comp_case (input i0 , input i1 , input i2 , input [1:0] sel, output reg y);
always @ (*)
begin
	case(sel)
		2'b00 : y = i0;
		2'b01 : y = i1;
		default : y = i2;
	endcase
end
endmodule

"
screenshot
here we can see there is no latch is infered ,fully combinational logic.
----
Bad case
"
module bad_case (input i0 , input i1, input i2, input i3 , input [1:0] sel, output reg y);
always @(*)
begin
	case(sel)
		2'b00: y = i0;
		2'b01: y = i1;
		2'b10: y = i2;
		2'b1?: y = i3;
		//2'b11: y = i3;
	endcase
end

endmodule
"
Reason:give reason
screenshots
---
Partial Assignment in case
"module partial_case_assign (input i0 , input i1 , input i2 , input [1:0] sel, output reg y , output reg x);
always @ (*)
begin
	case(sel)
		2'b00 : begin
			y = i0;
			x = i2;
			end
		2'b01 : y = i1;
		default : begin
		           x = i1;
			   y = i2;
			  end
	endcase
end
endmodule
"
Explanation:give little explanation
screenshot
---
For loop in Verilog
 -used within procedural blocks to execute statements multiple times based on counting
 Must be inside procedural blocks.
Synthesizable only if the number of iterations is fixed at compile time.
 syntax:
e.g:
"module mux_4to1_for_loop (
    input wire [3:0] data, // 4 input lines
    input wire [1:0] sel,  // 2-bit select
    output reg y           // Output
);
    integer i;
    always @(data, sel) begin
        y = 1'b0; // Default output
        for (i = 0; i < 4; i = i + 1) begin
            if (i == sel)
                y = data[i];
        end
    end
endmodule"
---
Generate Blocks in Verilog:
A generate block is used to create hardware structures such as module instances or logic at compile time. Typically used with for loops and the genvar keyword.
 e.g:
 genvar i;
generate
    for (i = 0; i < 4; i = i + 1) begin : gen_loop
        and_gate and_inst (.a(in[i]), .b(in[i+1]), .y(out[i]));
    end
endgenerate
---
Ripple Carry Adder:
  -An RCA adds binary numbers using a chain of full adders. To add n bits, you need n full adders. Each carry-out connects to the carry-in of the next stage.
  Image
  ---
  Labs

  1.4:1 MUX using for loop
  "module mux_generate (input i0 , input i1, input i2 , input i3 , input [1:0] sel  , output reg y);
wire [3:0] i_int;
assign i_int = {i3,i2,i1,i0};
integer k;
always @ (*)
begin
for(k = 0; k < 4; k=k+1) begin
	if(k == sel)
		y = i_int[k];
end
end
endmodule"
lab screenshot
2.8:1 DEMUX using case
"module demux_case (output o0 , output o1, output o2 , output o3, output o4, output o5, output o6 , output o7 , input [2:0] sel  , input i);
reg [7:0]y_int;
assign {o7,o6,o5,o4,o3,o2,o1,o0} = y_int;
integer k;
always @ (*)
begin
y_int = 8'b0;
	case(sel)
		3'b000 : y_int[0] = i;
		3'b001 : y_int[1] = i;
		3'b010 : y_int[2] = i;
		3'b011 : y_int[3] = i;
		3'b100 : y_int[4] = i;
		3'b101 : y_int[5] = i;
		3'b110 : y_int[6] = i;
		3'b111 : y_int[7] = i;
	endcase

end
endmodule
"
screenshots
3.8:1 DEMUX using For loop
"

module demux_generate (output o0 , output o1, output o2 , output o3, output o4, output o5, output o6 , output o7 , input [2:0] sel  , input i);
reg [7:0]y_int;
assign {o7,o6,o5,o4,o3,o2,o1,o0} = y_int;
integer k;
always @ (*)
begin
y_int = 8'b0;
for(k = 0; k < 8; k++) begin
	if(k == sel)
		y_int[k] = i;
end
end
endmodule
"
screenshot
---
4.8-bit Ripple Carry Adder with Generate Block
"module rca (input [7:0] num1 , input [7:0] num2 , output [8:0] sum);
wire [7:0] int_sum;
wire [7:0]int_co;

genvar i;
generate
	for (i = 1 ; i < 8; i=i+1) begin
		fa u_fa_1 (.a(num1[i]),.b(num2[i]),.c(int_co[i-1]),.co(int_co[i]),.sum(int_sum[i]));
	end

endgenerate
fa u_fa_0 (.a(num1[0]),.b(num2[0]),.c(1'b0),.co(int_co[0]),.sum(int_sum[0]));


assign sum[7:0] = int_sum;
assign sum[8] = int_co[7];
endmodule

"
Full Adder Module:
"module fa (input a, input b, input c, output co, output sum);
    assign {co, sum} = a + b + c;
endmodule"
screenshot
---
Summary

---  
"https://github.com/vlsienthusiast00x/RTL_workshop/tree/main/Day_5#2-inferred-latches-in-verilog"

